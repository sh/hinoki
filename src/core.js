// Generated by CoffeeScript 1.6.3
var Q, events;

events = require('events');

Q = require('q');

module.exports = {
  findInstance: function(getInstance) {
    return function(containers, id) {
      var container;
      container = find(containers, function(x) {
        return getInstance(x, id) != null;
      });
      return getInstance(container, id);
    };
  },
  findContainerThatContainsFactory: function(getFactory) {
    return function(containers, id) {
      return find(containers, function(x) {
        return getFactory(x, id) != null;
      });
    };
  },
  getInstance: function(getKey) {
    return function(container, id) {
      var _ref;
      return container != null ? (_ref = container.instances) != null ? _ref[getKey(id)] : void 0 : void 0;
    };
  },
  getFactory: function(getKey) {
    return function(container, id) {
      var _ref;
      return container != null ? (_ref = container.factories) != null ? _ref[getKey(id)] : void 0 : void 0;
    };
  },
  getEmitter: function(container) {
    if (container.emitter == null) {
      container.emitter = new events.EventEmitter;
    }
    return container.emitter;
  },
  getDependencies: function(parseFunctionArguments, getKey, getFactory) {
    return function(container, id) {
      var factory, key, _ref;
      key = getKey(id);
      if (((_ref = container.dependencies) != null ? _ref[key] : void 0) != null) {
        return container.dependencies[key];
      }
      factory = getFactory(container, id);
      if (factory == null) {
        return null;
      }
      return parseFunctionArguments(factory);
    };
  },
  setInstance: function(getKey) {
    return function(container, id, instance) {
      return Q(instance).then(function(value) {
        if (container.instances == null) {
          container.instances = {};
        }
        container.instances[getKey(id)] = value;
        return value;
      });
    };
  },
  setDependencies: function(getKey) {
    return function(container, id, dependencies) {
      return Q(dependencies).then(function(value) {
        if (container.dependencies == null) {
          container.dependencies = {};
        }
        container.dependencies[getKey(id)] = value;
        return value;
      });
    };
  },
  emit: function(getEmitter) {
    return function(container, id, event) {
      return getEmitter(arguments[0]).emit(Array.prototype.slice.call(arguments, 1));
    };
  },
  callFactory: function(_arg) {
    var emitInstance, emitPromise, emitRejected, emitResolved, exceptionRejection, factoryNotFoundRejection, getFactory, rejectionRejection;
    getFactory = _arg.getFactory, emitInstance = _arg.emitInstance, emitPromise = _arg.emitPromise, emitResolved = _arg.emitResolved, emitRejected = _arg.emitRejected, factoryNotFoundRejection = _arg.factoryNotFoundRejection, exceptionRejection = _arg.exceptionRejection, rejectionRejection = _arg.rejectionRejection;
    return function(container, id, dependencyInstances) {
      return Q(dependencyInstances).then(function(dependencyInstances) {
        var err, factory, instanceOrPromise, onReject, onResolve;
        factory = getFactory(container, id);
        if (factory == null) {
          return Q.reject(factoryNotFoundRejection(container, id));
        }
        try {
          instanceOrPromise = factory.apply(null, dependencyInstances);
        } catch (_error) {
          err = _error;
          return Q.reject(exceptionRejection(container, id, err));
        }
        if (!Q.isPromiseAlike(instanceOrPromise)) {
          emitInstance(container, id, instanceOrPromise);
          return Q(instanceOrPromise);
        }
        emitPromise(container, id, instanceOrPromise);
        onResolve = function(value) {
          emitResolved(container, id, value);
          return Q(value);
        };
        onReject = function(rejection) {
          return Q.reject(rejectionRejection(container, id, rejection));
        };
        return instanceOrPromise.then(onResolve, onReject);
      });
    };
  },
  overloadedInject: function(_arg) {
    var arrayify, inject, parseFunctionArguments;
    arrayify = _arg.arrayify, parseFunctionArguments = _arg.parseFunctionArguments, inject = _arg.inject;
    return function() {
      var cb, containers, dependencyIds, len;
      len = arguments.length;
      if (!((len === 2) || (len === 3))) {
        throw new Error("2 or 3 arguments required but " + len + " were given");
      }
      containers = arrayify(arguments[0]);
      if (containers.length === 0) {
        throw new Error('at least 1 container is required');
      }
      cb = len === 2 ? arguments[1] : arguments[2];
      if ('function' !== typeof cb) {
        throw new Error('cb must be a function');
      }
      dependencyIds = len === 2 ? parseFunctionArguments(cb) : arguments[1];
      return inject(containers, dependencyIds, cb);
    };
  },
  inject: function(getOrCreateManyInstances, emitRejection) {
    return function(containers, ids, cb) {
      var onReject, onResolve, promise;
      onResolve = function(instances) {
        return process.nextTick(function() {
          return cb.apply(null, instances);
        });
      };
      onReject = function(rejection) {
        return process.nextTick(function() {
          return emitRejection(rejection);
        });
      };
      promise = getOrCreateManyInstances(containers, ids);
      return promise.done(onResolve, onReject);
    };
  },
  getOrCreateManyInstances: function(getOrCreateInstance) {
    return function(containers, ids) {
      return Q.all(ids.map(function(id) {
        return getOrCreateInstance(containers, id);
      }));
    };
  },
  getOrCreateInstance: function(getInstance, getContainerThatContainsFactory, getFactoryDependencies, sliceStartingAt, getInstancesAsPromise, createInstance, hasCycle) {
    return function(containers, id) {
      var container, factory, instance, remainingContainers;
      instance = findInstance(containers, id);
      if (instance != null) {
        emit(containers[0], 'instanceFound', id, instance);
        return Q.resolve(instance);
      }
      if (hasCycle(id)) {
        return createRejection('cycle', containers[0], id);
      }
      container = getContainerThatContainsFactory(containers, id);
      if (container == null) {
        return createRejection('factoryNotFound', containers[0], id);
      }
      factory = getFactory(container, id);
      if ('function' !== typeof factory) {
        return createRejection('factoryNotFunction', container, id);
      }
      remainingContainers = getStartingWith(containers, container);
      return instance = createInstance(container, remainingContainers, id);
    };
  },
  createInstance: function(getDependencies, getInstances, callFactory) {
    return function(container, id, containers) {
      var dependenciesSet, dependencyIds, dependencyInstances, factory, instance, instanceSet;
      dependencyIds = getDependencies(container, id);
      dependencyIds = dependencyIds.map(function(x) {
        return addToId(id, x);
      });
      dependencyInstances = getInstances(containers, dependencyIds);
      factory = getFactory(container, id);
      instance = callFactory(container, factory, dependencyInstances);
      instanceSet = setInstance(container, id, instance);
      dependenciesSet = setDependencies(container, id, dependencyInstances);
      return Q.all([instanceSet, dependenciesSet]).then(function() {
        return instance;
      });
    };
  },
  createRejection: function(getEmitter) {
    return function(reason, container, id, err) {
      return {
        reason: reason,
        container: getEmitter(container),
        id: id,
        err: err
      };
    };
  },
  emitRejection: function(emit, rejectionToError) {
    return function(rejection) {
      return emit(rejection.container, 'error', rejectionToError(rejection));
    };
  },
  rejectionToError: function(getKeys, idToString) {
    return function(rejection) {
      var id;
      id = rejection.id;
      return new Error((function() {
        switch (rejection.type) {
          case 'circle':
            return "circular dependency " + (idToString(id));
          case 'factoryNotFound':
            return "missing factory '" + (getKey(id)) + "' (" + (idToString(id)) + ")";
          case 'exception':
            return "exception in factory '" + (getKey(id)) + "': " + reason.err;
          case 'rejection':
            return "promise returned from factory '" + (getKey(id)) + "' was rejected with: " + reason.err;
          case 'factoryNotFunction':
            return "factory '" + (getKey(id)) + "' is not a function: " + reason.factory;
        }
      })());
    };
  },
  idToString: function(getKeys) {
    return function(id) {
      return getKeys(id).join(' <- ');
    };
  },
  getKey: function(id) {
    if (Array.isArray(id)) {
      return id[0];
    } else {
      return id;
    }
  },
  getKeys: function(arrayify) {
    return function(id) {
      return arrayify(id);
    };
  },
  isCyclic: function(getKeys, arrayOfStringsHasDuplicate) {
    return function(id) {
      return arrayOfStringsHasDuplicate(getKeys(id));
    };
  },
  addToId: function(arrayify) {
    return function(id, key) {
      return [key].concat(arrayify(id));
    };
  }
};
