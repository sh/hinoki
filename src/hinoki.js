// Generated by CoffeeScript 1.7.1
(function() {
  var newHinoki;
  newHinoki = function(Promise) {
    var hinoki;
    hinoki = {};
    hinoki.get = function(oneOrManyContainers, oneOrManyIdsOrPaths, debug) {
      var containers;
      containers = hinoki.arrayify(oneOrManyContainers);
      if (containers.length === 0) {
        throw new Error('at least 1 container is required');
      }
      if (Array.isArray(oneOrManyIdsOrPaths)) {
        return hinoki.getMany(containers, oneOrManyIdsOrPaths, debug);
      } else {
        return hinoki.getOne(containers, oneOrManyIdsOrPaths, debug);
      }
    };
    hinoki.getMany = function(containers, idsOrPaths, debug) {
      return Promise.all(idsOrPaths).map(function(idOrPath) {
        return hinoki.getOne(containers, idOrPath, debug);
      });
    };
    hinoki.getOne = function(containers, idOrPath, debug) {
      var error, factoryResultPromise, instanceResultPromise, path;
      path = hinoki.castPath(idOrPath);
      instanceResultPromise = hinoki.resolveInstanceInContainers(containers, path);
      if (instanceResultPromise != null) {
        return instanceResultPromise.then(function(instanceResult) {
          if (typeof debug === "function") {
            debug({
              event: 'instanceResolved',
              id: path.id(),
              path: path.segments(),
              instance: instanceResult.instance,
              resolver: instanceResult.resolver,
              container: instanceResult.container
            });
          }
          return instanceResult.instance;
        });
      }
      if (path.isCyclic()) {
        error = new hinoki.CircularDependencyError(path, containers[0]);
        return Promise.reject(error);
      }
      factoryResultPromise = hinoki.resolveFactoryInContainers(containers, path);
      if (factoryResultPromise == null) {
        error = new hinoki.UnresolvableFactoryError(path, containers[0]);
        return Promise.reject(error);
      }
      return factoryResultPromise.then(function(factoryResult) {
        var container, dependenciesPromise, dependencyIds, factory, instancePromise, remainingContainers, resolver, underConstruction;
        factory = factoryResult.factory, resolver = factoryResult.resolver, container = factoryResult.container;
        if (typeof debug === "function") {
          debug({
            event: 'factoryFound',
            id: path.id(),
            path: path.segments(),
            factory: factory,
            resolver: resolver,
            container: container
          });
        }
        underConstruction = container.getUnderConstruction(container, path.id());
        if (underConstruction != null) {
          if (typeof debug === "function") {
            debug({
              event: 'instanceUnderConstruction',
              id: path.id(),
              path: path.segments(),
              value: underConstruction,
              container: container
            });
          }
          return underConstruction;
        }
        remainingContainers = hinoki.startingWith(containers, container);
        dependencyIds = hinoki.getIdsToInject(factory);
        dependencyIds = dependencyIds.map(function(x) {
          return hinoki.castPath(x).concat(path);
        });
        dependenciesPromise = hinoki.get(remainingContainers, dependencyIds, debug);
        instancePromise = dependenciesPromise.then(function(dependencyInstances) {
          return hinoki.callFactory(container, path, factory, dependencyInstances, debug);
        });
        container.setUnderConstruction(container, path.id(), instancePromise);
        return instancePromise.then(function(value) {
          if (hinoki.isUndefined(value)) {
            error = new hinoki.FactoryReturnedUndefinedError(path, container, factory);
            return Promise.reject(error);
          }
          container.setInstance(container, path.id(), value);
          container.unsetUnderConstruction(container, path.id());
          return value;
        });
      });
    };
    hinoki.callFactory = function(container, idOrPath, factory, dependencyInstances, debug) {
      var error, exception, instanceOrPromise, path;
      path = hinoki.castPath(idOrPath);
      try {
        instanceOrPromise = factory.apply(null, dependencyInstances);
      } catch (_error) {
        exception = _error;
        error = new hinoki.ExceptionInFactoryError(path, container, exception);
        return Promise.reject(error);
      }
      if (!hinoki.isThenable(instanceOrPromise)) {
        if (typeof debug === "function") {
          debug({
            event: 'instanceCreated',
            id: path.id(),
            path: path.segments(),
            instance: instanceOrPromise,
            factory: factory,
            container: container
          });
        }
        return Promise.resolve(instanceOrPromise);
      }
      if (typeof debug === "function") {
        debug({
          event: 'promiseCreated',
          id: path.id(),
          path: path.segments(),
          promise: instanceOrPromise,
          container: container,
          factory: factory
        });
      }
      return Promise.resolve(instanceOrPromise).then(function(value) {
        if (typeof debug === "function") {
          debug({
            event: 'promiseResolved',
            id: path.id(),
            path: path.segments(),
            value: value,
            container: container,
            factory: factory
          });
        }
        return value;
      })["catch"](function(rejection) {
        error = new hinoki.PromiseRejectedError(path, container, rejection);
        return Promise.reject(error);
      });
    };
    hinoki.resolveFactoryInContainer = function(container, idOrPath) {
      var path;
      path = hinoki.castPath(idOrPath);
      return hinoki.some(container.factoryResolvers, function(resolver) {
        var error, factory;
        factory = resolver(container, path.id());
        if (factory == null) {
          return;
        }
        if ('function' !== typeof factory) {
          error = new hinoki.FactoryNotFunctionError(path, container, factory);
          return Promise.reject(error);
        }
        return Promise.resolve({
          resolver: resolver,
          factory: factory
        });
      });
    };
    hinoki.resolveFactoryInContainers = function(containers, idOrPath) {
      var path;
      path = hinoki.castPath(idOrPath);
      return hinoki.some(containers, function(container) {
        var promise;
        promise = hinoki.resolveFactoryInContainer(container, path);
        if (promise == null) {
          return;
        }
        return promise.then(function(result) {
          result.container = container;
          return result;
        });
      });
    };
    hinoki.resolveInstanceInContainer = function(container, idOrPath) {
      var path;
      path = hinoki.castPath(idOrPath);
      return hinoki.some(container.instanceResolvers, function(resolver) {
        var instance;
        instance = resolver(container, path.id());
        if (instance == null) {
          return;
        }
        return Promise.resolve({
          resolver: resolver,
          instance: instance
        });
      });
    };
    hinoki.resolveInstanceInContainers = function(containers, idOrPath) {
      var path;
      path = hinoki.castPath(idOrPath);
      return hinoki.some(containers, function(container) {
        var promise;
        promise = hinoki.resolveInstanceInContainer(container, path);
        if (promise == null) {
          return;
        }
        return promise.then(function(result) {
          result.container = container;
          return result;
        });
      });
    };
    hinoki.newContainer = function(factories, instances) {
      if (factories == null) {
        factories = {};
      }
      if (instances == null) {
        instances = {};
      }
      return {
        factories: factories,
        instances: instances,
        factoryResolvers: [hinoki.defaultFactoryResolver],
        instanceResolvers: [hinoki.defaultInstanceResolver],
        underConstruction: {},
        setInstance: hinoki.defaultSetInstance,
        setUnderConstruction: hinoki.defaultSetUnderConstruction,
        unsetUnderConstruction: hinoki.defaultUnsetUnderConstruction,
        getUnderConstruction: hinoki.defaultGetUnderConstruction
      };
    };
    hinoki.defaultInstanceResolver = function(container, id) {
      var _ref;
      return (_ref = container.instances) != null ? _ref[id] : void 0;
    };
    hinoki.defaultFactoryResolver = function(container, id) {
      var factory, _ref;
      factory = (_ref = container.factories) != null ? _ref[id] : void 0;
      if (factory == null) {
        return;
      }
      if ((factory.$inject == null) && 'function' === typeof factory) {
        factory.$inject = hinoki.parseFunctionArguments(factory);
      }
      return factory;
    };
    hinoki.defaultSetInstance = function(container, id, instance) {
      return container.instances[id] = instance;
    };
    hinoki.defaultSetUnderConstruction = function(container, id, underConstruction) {
      return container.underConstruction[id] = underConstruction;
    };
    hinoki.defaultUnsetUnderConstruction = function(container, id) {
      var value;
      value = container.underConstruction[id];
      delete container.underConstruction[id];
      return value;
    };
    hinoki.defaultGetUnderConstruction = function(container, id) {
      return container.underConstruction[id];
    };
    hinoki.CircularDependencyError = function(path, container) {
      this.message = "circular dependency " + (path.toString());
      this.name = 'CircularDependencyError';
      this.id = path.id();
      this.path = path.segments();
      this.container = container;
      if (Error.captureStackTrace) {
        return Error.captureStackTrace(this, this.constructor);
      }
    };
    hinoki.CircularDependencyError.prototype = new Error;
    hinoki.UnresolvableFactoryError = function(path, container) {
      this.message = "unresolvable factory '" + (path.id()) + "' (" + (path.toString()) + ")";
      this.name = 'UnresolvableFactoryError';
      this.id = path.id();
      this.path = path.segments();
      this.container = container;
      if (Error.captureStackTrace) {
        return Error.captureStackTrace(this, this.constructor);
      }
    };
    hinoki.UnresolvableFactoryError.prototype = new Error;
    hinoki.ExceptionInFactoryError = function(path, container, exception) {
      this.message = "exception in factory '" + (path.id()) + "': " + exception;
      this.name = 'ExceptionInFactoryError';
      this.id = path.id();
      this.path = path.segments();
      this.container = container;
      this.exception = exception;
      if (Error.captureStackTrace) {
        return Error.captureStackTrace(this, this.constructor);
      }
    };
    hinoki.ExceptionInFactoryError.prototype = new Error;
    hinoki.PromiseRejectedError = function(path, container, rejection) {
      this.message = "promise returned from factory '" + (path.id()) + "' was rejected with reason: " + rejection;
      this.name = 'PromiseRejectedError';
      this.id = path.id();
      this.path = path.segments();
      this.container = container;
      this.rejection = rejection;
      if (Error.captureStackTrace) {
        return Error.captureStackTrace(this, this.constructor);
      }
    };
    hinoki.PromiseRejectedError.prototype = new Error;
    hinoki.FactoryNotFunctionError = function(path, container, factory) {
      this.message = "factory '" + (path.id()) + "' is not a function: " + factory;
      this.name = 'FactoryNotFunctionError';
      this.id = path.id();
      this.path = path.segments();
      this.container = container;
      this.factory = factory;
      if (Error.captureStackTrace) {
        return Error.captureStackTrace(this, this.constructor);
      }
    };
    hinoki.FactoryNotFunctionError.prototype = new Error;
    hinoki.FactoryReturnedUndefinedError = function(path, container, factory) {
      this.message = "factory '" + (path.id()) + "' returned undefined";
      this.name = 'FactoryReturnedUndefinedError';
      this.id = path.id();
      this.path = path.segments();
      this.container = container;
      this.factory = factory;
      if (Error.captureStackTrace) {
        return Error.captureStackTrace(this, this.constructor);
      }
    };
    hinoki.FactoryReturnedUndefinedError.prototype = new Error;
    hinoki.PathPrototype = {
      toString: function() {
        return this.$segments.join(' <- ');
      },
      id: function() {
        return this.$segments[0];
      },
      segments: function() {
        return this.$segments;
      },
      concat: function(otherValue) {
        var otherPath, segments;
        otherPath = hinoki.castPath(otherValue);
        segments = this.$segments.concat(otherPath.$segments);
        return hinoki.newPath(segments);
      },
      isCyclic: function() {
        return hinoki.arrayOfStringsHasDuplicates(this.$segments);
      }
    };
    hinoki.newPath = function(segments) {
      var id;
      id = Object.create(hinoki.PathPrototype);
      id.$segments = segments;
      return id;
    };
    hinoki.castPath = function(value) {
      if (hinoki.PathPrototype.isPrototypeOf(value)) {
        return value;
      } else if ('string' === typeof value) {
        return hinoki.newPath([value]);
      } else if (Array.isArray(value)) {
        return hinoki.newPath(value);
      } else {
        throw new Error("value " + value + " can not be cast to id");
      }
    };
    hinoki.isObject = function(x) {
      return x === Object(x);
    };
    hinoki.isThenable = function(x) {
      return hinoki.isObject(x) && 'function' === typeof x.then;
    };
    hinoki.isUndefined = function(x) {
      return 'undefined' === typeof x;
    };
    hinoki.isNull = function(x) {
      return null === x;
    };
    hinoki.isExisting = function(x) {
      return x != null;
    };
    hinoki.identity = function(x) {
      return x;
    };
    hinoki.some = function(array, iterator, predicate, sentinel) {
      var i, length, result;
      if (iterator == null) {
        iterator = hinoki.identity;
      }
      if (predicate == null) {
        predicate = hinoki.isExisting;
      }
      if (sentinel == null) {
        sentinel = void 0;
      }
      i = 0;
      length = array.length;
      while (i < length) {
        result = iterator(array[i], i);
        if (predicate(result, i)) {
          return result;
        }
        i++;
      }
      return sentinel;
    };
    hinoki.arrayOfStringsHasDuplicates = function(array) {
      var i, length, value, valuesSoFar;
      i = 0;
      length = array.length;
      valuesSoFar = {};
      while (i < length) {
        value = array[i];
        if (Object.prototype.hasOwnProperty.call(valuesSoFar, value)) {
          return true;
        }
        valuesSoFar[value] = true;
        i++;
      }
      return false;
    };
    hinoki.arrayify = function(arg) {
      if (Array.isArray(arg)) {
        return arg;
      }
      if (arg == null) {
        return [];
      }
      return [arg];
    };
    hinoki.startingWith = function(xs, x) {
      var index;
      index = xs.indexOf(x);
      if (index === -1) {
        return [];
      }
      return xs.slice(index);
    };
    hinoki.parseFunctionArguments = function(fun) {
      var argumentPart, dependencies, string;
      if ('function' !== typeof fun) {
        throw new Error('argument must be a function');
      }
      string = fun.toString();
      argumentPart = string.slice(string.indexOf('(') + 1, string.indexOf(')'));
      dependencies = argumentPart.match(/([^\s,]+)/g);
      if (dependencies) {
        return dependencies;
      } else {
        return [];
      }
    };
    hinoki.getIdsToInject = function(factory) {
      if (factory.$inject != null) {
        return factory.$inject;
      } else {
        return hinoki.parseFunctionArguments(factory);
      }
    };
    return hinoki;
  };
  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    return module.exports = newHinoki(require('bluebird'));
  } else {
    if (window.Promise == null) {
      throw new Error('hinoki requires Promise global by bluebird');
    }
    return window.hinoki = newHinoki(window.Promise);
  }
})();
