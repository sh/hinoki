// Generated by CoffeeScript 1.6.3
var Q, checkDeps, events,
  __slice = [].slice;

events = require('events');

Q = require('q');

checkDeps = function() {
  var deps, names;
  deps = arguments[0], names = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return names.map(function(name) {
    if (deps[name] == null) {
      throw new Error("missing dependency " + name);
    }
  });
};

module.exports = {
  inject: function(deps) {
    checkDeps(deps, 'arrayify', 'parseFunctionArguments', '_inject');
    return function() {
      var cb, containers, dependencyIds, len;
      len = arguments.length;
      if (!((len === 2) || (len === 3))) {
        throw new Error("2 or 3 arguments required but " + len + " were given");
      }
      containers = deps.arrayify(arguments[0]);
      if (containers.length === 0) {
        throw new Error('at least 1 container is required');
      }
      cb = len === 2 ? arguments[1] : arguments[2];
      if ('function' !== typeof cb) {
        throw new Error('cb must be a function');
      }
      dependencyIds = len === 2 ? deps.parseFunctionArguments(cb) : arguments[1];
      return deps._inject(containers, dependencyIds, cb);
    };
  },
  _inject: function(deps) {
    checkDeps(deps, 'emitRejection', 'getOrCreateManyInstances');
    return function(containers, ids, cb) {
      var onReject, onResolve, promise;
      onResolve = function(instances) {
        return process.nextTick(function() {
          return cb.apply(null, instances);
        });
      };
      onReject = function(rejection) {
        return deps.emitRejection(rejection);
      };
      promise = deps.getOrCreateManyInstances(containers, ids);
      return promise.done(onResolve, onReject);
    };
  },
  getOrCreateManyInstances: function(deps) {
    checkDeps(deps, 'getOrCreateInstance');
    return function(containers, ids) {
      return Q.all(ids.map(function(id) {
        return deps.getOrCreateInstance(containers, id);
      }));
    };
  },
  getOrCreateInstance: function(deps) {
    checkDeps(deps, 'findInstance', 'emitInstanceFound', 'hasCycle', 'cycleRejection', 'findContainerThatContainsFactory', 'factoryNotFoundRejection', 'getFactory', 'factoryNotFunctionRejection', 'startingWith', 'createInstance');
    return function(containers, id) {
      var container, factory, instance, remainingContainers;
      instance = deps.findInstance(containers, id);
      if (instance != null) {
        deps.emitInstanceFound(containers[0], id, instance);
        return Q.resolve(instance);
      }
      if (deps.hasCycle(id)) {
        return deps.cycleRejection(containers[0], id);
      }
      container = deps.findContainerThatContainsFactory(containers, id);
      if (container == null) {
        return deps.factoryNotFoundRejection(containers[0], id);
      }
      factory = deps.getFactory(container, id);
      if ('function' !== typeof factory) {
        return deps.factoryNotFunctionRejection(container, id, factory);
      }
      remainingContainers = deps.startingWith(containers, container);
      return instance = deps.createInstance(container, remainingContainers, id);
    };
  },
  createInstance: function(deps) {
    checkDeps(deps, 'getDependencies', 'getInstances', 'callFactory', 'cacheDependencies');
    return function(container, id, containers) {
      var dependenciesCached, dependencyIds, dependencyInstances, factory, instance, instanceSet;
      dependencyIds = deps.getDependencies(container, id);
      dependencyIds = dependencyIds.map(function(x) {
        return addToId(id, x);
      });
      dependencyInstances = deps.getInstances(containers, dependencyIds);
      factory = getFactory(container, id);
      instance = deps.callFactory(container, factory, dependencyInstances);
      instanceSet = setInstance(container, id, instance);
      dependenciesCached = deps.cacheDependencies(container, id, dependencyInstances);
      return Q.all([instanceSet, dependenciesCached]).then(function() {
        return instance;
      });
    };
  },
  callFactory: function(deps) {
    checkDeps(deps, 'getFactory', 'missingFactoryRejection', 'exceptionRejection', 'emitInstanceCreated', 'emitPromiseCreated', 'emitPromiseResolved', 'rejectionRejection');
    return function(container, id, dependencyInstances) {
      return Q(dependencyInstances).then(function(dependencyInstances) {
        var err, factory, instanceOrPromise, onReject, onResolve;
        factory = deps.getFactory(container, id);
        if (factory == null) {
          return deps.missingFactoryRejection(container, id);
        }
        try {
          instanceOrPromise = factory.apply(null, dependencyInstances);
        } catch (_error) {
          err = _error;
          return deps.exceptionRejection(container, id, err);
        }
        if (!Q.isPromiseAlike(instanceOrPromise)) {
          deps.emitInstanceCreated(container, id, instanceOrPromise);
          return Q(instanceOrPromise);
        }
        deps.emitPromiseCreated(container, id, instanceOrPromise);
        onResolve = function(value) {
          deps.emitPromiseResolved(container, id, value);
          return value;
        };
        onReject = function(rejection) {
          return deps.rejectionRejection(container, id, rejection);
        };
        return instanceOrPromise.then(onResolve, onReject);
      });
    };
  },
  getKey: function() {
    return function(id) {
      if (Array.isArray(id)) {
        return id[0];
      } else {
        return id;
      }
    };
  },
  getKeys: function(deps) {
    checkDeps(deps, 'arrayify');
    return function(id) {
      return deps.arrayify(id);
    };
  },
  idToString: function(deps) {
    checkDeps(deps, 'getKeys');
    return function(id) {
      return deps.getKeys(id).join(' <- ');
    };
  },
  addToId: function(deps) {
    checkDeps(deps, 'arrayify');
    return function(id, key) {
      return [key].concat(deps.arrayify(id));
    };
  },
  isCyclic: function(deps) {
    checkDeps(deps, 'arrayOfStringsHasDuplicate');
    return function(id) {
      return deps.arrayOfStringsHasDuplicate(getKeys(id));
    };
  },
  getEmitter: function() {
    return function(container) {
      if (container.emitter == null) {
        container.emitter = new events.EventEmitter;
      }
      return container.emitter;
    };
  },
  getInstance: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id) {
      var _ref;
      return container != null ? (_ref = container.instances) != null ? _ref[deps.getKey(id)] : void 0 : void 0;
    };
  },
  getFactory: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id) {
      var _ref;
      return container != null ? (_ref = container.factories) != null ? _ref[deps.getKey(id)] : void 0 : void 0;
    };
  },
  getDependencies: function(deps) {
    checkDeps(deps, 'getKey', 'getFactory', 'parseFunctionArguments');
    return function(container, id) {
      var factory, key, _ref;
      key = deps.getKey(id);
      if (((_ref = container.dependencies) != null ? _ref[key] : void 0) != null) {
        return container.dependencies[key];
      }
      factory = deps.getFactory(container, id);
      if (factory == null) {
        return null;
      }
      return deps.parseFunctionArguments(factory);
    };
  },
  findContainerThatContainsFactory: function(deps) {
    checkDeps(deps, 'find', 'getFactory');
    return function(containers, id) {
      return deps.find(containers, function(x) {
        return deps.getFactory(x, id) != null;
      });
    };
  },
  findContainerThatContainsInstance: function(deps) {
    checkDeps(deps, 'find', 'getInstance');
    return function(containers, id) {
      return deps.find(containers, function(x) {
        return deps.getFactory(x, id) != null;
      });
    };
  },
  findInstance: function(deps) {
    checkDeps(deps, 'find', 'findContainerThatContainsInstance');
    return function(containers, id) {
      var container;
      container = deps.find(containers, function(x) {
        return deps.getInstance(x, id) != null;
      });
      return deps.getInstance(container, id);
    };
  },
  setInstance: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id, instance) {
      return Q(instance).then(function(value) {
        if (container.instances == null) {
          container.instances = {};
        }
        container.instances[deps.getKey(id)] = value;
        return value;
      });
    };
  },
  cacheDependencies: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id, dependencies) {
      return Q(dependencies).then(function(value) {
        if (container.dependencyCache == null) {
          container.dependencyCache = {};
        }
        container.dependencyCache[deps.getKey(id)] = value;
        return value;
      });
    };
  },
  emit: function(deps) {
    checkDeps(deps, 'getEmitter', 'event');
    return function(container) {
      return deps.getEmitter(container).emit(deps.event(Array.prototype.slice.call(arguments, 1)));
    };
  },
  cycleRejection: function(deps) {
    checkDeps(deps, 'idToString');
    return function(container, id) {
      var error;
      error = new Error("circular dependency " + (deps.idToString(id)));
      error.name = 'cycle';
      error.id = id;
      error.container = container;
      return Q.reject(error);
    };
  },
  missingFactoryRejection: function(deps) {
    checkDeps(deps, 'getKey', 'idToString');
    return function(container, id) {
      var error;
      error = new Error("missing factory '" + (deps.getKey(id)) + "' (" + (deps.idToString(id)) + ")");
      error.name = 'missingFactory';
      error.id = id;
      error.container = container;
      return Q.reject(error);
    };
  },
  exceptionRejection: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id, exception) {
      var error;
      error = new Error("exception in factory '" + (deps.getKey(id)) + "': " + err);
      error.name = 'exceptionRejection';
      error.exception = exception;
      error.id = id;
      error.container = container;
      return Q.reject(error);
    };
  },
  rejectionRejection: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id, rejection) {
      var error;
      error = new Error("promise returned from factory '" + (deps.getKey(id)) + "' was rejected with: " + rejection);
      error.name = 'rejectionRejection';
      error.rejection = rejection;
      error.id = id;
      error.container = container;
      return Q.reject(error);
    };
  },
  factoryNotFunctionRejection: function(deps) {
    checkDeps(deps, 'getKey');
    return function(container, id, factory) {
      var error;
      error = "factory '" + (deps.getKey(id)) + "' is not a function: " + factory;
      error.name = 'factoryNotFunction';
      error.factory = factory;
      error.id = id;
      error.container = container;
      return Q.reject(error);
    };
  },
  emitRejection: function(deps) {
    checkDeps(deps, 'getKey');
    return function(rejection) {
      return deps.emit(rejection.container, 'error', rejection);
    };
  }
};
