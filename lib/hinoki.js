// Generated by CoffeeScript 1.9.1
(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define(['bluebird'], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory(require('bluebird'));
  } else {
    return root.hinoki = factory(root.Promise);
  }
})(this, function(Promise) {
  var hinoki;
  hinoki = {};
  hinoki.get = function(oneOrManyContainers, oneOrManyNamesOrPaths, debug) {
    var containers;
    containers = hinoki.coerceToArray(oneOrManyContainers);
    if (containers.length === 0) {
      throw new Error('at least 1 container is required');
    }
    if (Array.isArray(oneOrManyNamesOrPaths)) {
      return Promise.all(oneOrManyNamesOrPaths).map(function(nameOrPath) {
        return hinoki.getOne(containers, nameOrPath, debug);
      });
    } else {
      return hinoki.getOne(containers, oneOrManyNamesOrPaths, debug);
    }
  };
  hinoki.getOne = function(containers, nameOrPath, debug) {
    var base, dependenciesPromise, dependencyNames, dependencyPaths, error, factoryCallResultPromise, newPath, nocache, path, promiseAwaitingResolution, ref, remainingContainers, resolution, resolutionErrors;
    path = hinoki.coerceToArray(nameOrPath);
    try {
      resolution = hinoki.resolveInContainers(containers, path, debug);
    } catch (_error) {
      error = _error;
      return Promise.reject(new hinoki.ErrorInResolversError(path, containers, error));
    }
    if (resolution instanceof Error) {
      return Promise.reject(new hinoki.ErrorInResolversError(path, containers, resolution));
    }
    if (resolution == null) {
      return Promise.reject(new hinoki.UnresolvableError(path, containers));
    }
    resolutionErrors = hinoki.resolutionErrors(resolution);
    if (resolutionErrors != null) {
      return Promise.reject(new hinoki.InvalidResolutionError(path, resolution, resolutionErrors));
    }
    if (!hinoki.isUndefined(resolution.value)) {
      if (typeof debug === "function") {
        debug({
          event: 'valueWasResolved',
          path: path,
          resolution: resolution
        });
      }
      return Promise.resolve(resolution.value);
    }
    if (hinoki.arrayOfStringsHasDuplicates(path)) {
      return Promise.reject(new hinoki.CircularDependencyError(path, resolution));
    }
    if (typeof debug === "function") {
      debug({
        event: 'factoryWasResolved',
        path: path,
        resolution: resolution
      });
    }
    nocache = resolution.nocache || resolution.factory.$nocache;
    if (!nocache) {
      promiseAwaitingResolution = (ref = resolution.container.promisesAwaitingResolution) != null ? ref[resolution.name] : void 0;
      if (promiseAwaitingResolution != null) {
        if (typeof debug === "function") {
          debug({
            event: 'valueIsAlreadyAwaitingResolution',
            path: path,
            resolution: resolution,
            promise: promiseAwaitingResolution
          });
        }
        return promiseAwaitingResolution;
      }
    }
    remainingContainers = hinoki.startingWith(containers, resolution.container);
    dependencyNames = hinoki.getNamesToInject(resolution.factory);
    newPath = path.slice();
    newPath[0] = resolution.name;
    dependencyPaths = dependencyNames.map(function(x) {
      return hinoki.coerceToArray(x).concat(newPath);
    });
    dependenciesPromise = dependencyPaths.length !== 0 ? hinoki.get(remainingContainers, dependencyPaths, debug) : Promise.resolve([]);
    factoryCallResultPromise = dependenciesPromise.then(function(dependencyValues) {
      return hinoki.callFactory(resolution.container, newPath, resolution.factory, dependencyValues, debug);
    });
    if (!nocache) {
      if ((base = resolution.container).promisesAwaitingResolution == null) {
        base.promisesAwaitingResolution = {};
      }
      resolution.container.promisesAwaitingResolution[resolution.name] = factoryCallResultPromise;
    }
    return factoryCallResultPromise.then(function(value) {
      var base1;
      if (hinoki.isUndefined(value)) {
        return Promise.reject(new hinoki.FactoryReturnedUndefinedError(newPath, resolution.container, resolution.factory));
      }
      if (!nocache) {
        if ((base1 = resolution.container).values == null) {
          base1.values = {};
        }
        resolution.container.values[resolution.name] = value;
      }
      return value;
    })["finally"](function() {
      if (!nocache) {
        delete resolution.container.promisesAwaitingResolution[resolution.name];
        if (Object.keys(resolution.container.promisesAwaitingResolution).length === 0) {
          return delete resolution.container.promisesAwaitingResolution;
        }
      }
    });
  };
  hinoki.callFactory = function(container, nameOrPath, factory, dependencyValues, debug) {
    var error, path, valueOrPromise;
    path = hinoki.coerceToArray(nameOrPath);
    try {
      valueOrPromise = factory.apply(null, dependencyValues);
    } catch (_error) {
      error = _error;
      return Promise.reject(new hinoki.ThrowInFactoryError(path, container, error));
    }
    if (!hinoki.isThenable(valueOrPromise)) {
      if (typeof debug === "function") {
        debug({
          event: 'valueWasCreated',
          path: path,
          value: valueOrPromise,
          factory: factory,
          container: container
        });
      }
      return Promise.resolve(valueOrPromise);
    }
    if (typeof debug === "function") {
      debug({
        event: 'promiseWasCreated',
        path: path,
        promise: valueOrPromise,
        container: container,
        factory: factory
      });
    }
    return Promise.resolve(valueOrPromise).then(function(value) {
      if (typeof debug === "function") {
        debug({
          event: 'promiseWasResolved',
          path: path,
          value: value,
          container: container,
          factory: factory
        });
      }
      return value;
    })["catch"](function(rejection) {
      return Promise.reject(new hinoki.PromiseRejectedError(path, container, rejection));
    });
  };
  hinoki.resolveInContainer = function(container, nameOrPath, debug) {
    var accum, defaultResolver, path, resolution, resolve, resolvers;
    path = hinoki.coerceToArray(nameOrPath);
    defaultResolver = function(name) {
      var resolution;
      resolution = hinoki.defaultResolver(name, container);
      if (typeof debug === "function") {
        debug({
          event: 'defaultResolverWasCalled',
          path: path,
          container: container,
          resolution: resolution
        });
      }
      return resolution;
    };
    resolvers = hinoki.coerceToArray(container.resolvers || []);
    accum = function(inner, resolver) {
      return function(name) {
        var resolution;
        resolution = resolver(name, container, inner, debug);
        if (typeof debug === "function") {
          debug({
            event: 'customResolverWasCalled',
            resolver: resolver,
            path: path,
            container: container,
            resolution: resolution
          });
        }
        return resolution;
      };
    };
    resolve = resolvers.reduceRight(accum, defaultResolver);
    resolution = resolve(path[0]);
    if ((resolution != null) && 'object' === typeof resolution) {
      resolution.container = container;
    }
    return resolution;
  };
  hinoki.resolveInContainers = function(containers, nameOrPath, debug) {
    var path;
    path = hinoki.coerceToArray(nameOrPath);
    return hinoki.some(containers, function(container) {
      return hinoki.resolveInContainer(container, path, debug);
    });
  };
  hinoki.resolutionErrors = function(resolution) {
    var errors, isFactory, isValue;
    errors = [];
    if ('object' !== typeof resolution) {
      errors.push('must be an object');
    }
    if (!(((resolution != null ? resolution.name : void 0) != null) && 'string' === typeof (resolution != null ? resolution.name : void 0))) {
      errors.push("must have the 'name' property which is a string");
    }
    isValue = !hinoki.isUndefined(resolution != null ? resolution.value : void 0);
    isFactory = (resolution != null ? resolution.factory : void 0) != null;
    if (!(isValue || isFactory)) {
      errors.push("must have either the 'value' or the 'factory' property");
    } else if (isValue && isFactory) {
      errors.push("must have either the 'value' or the 'factory' property - not both");
    } else if (isFactory && 'function' !== typeof resolution.factory) {
      errors.push("the 'factory' property must be a function");
    }
    if (errors.length === 0) {
      return null;
    } else {
      return errors;
    }
  };
  hinoki.defaultResolver = function(name, container) {
    var factory, ref, ref1, value;
    value = (ref = container.values) != null ? ref[name] : void 0;
    if (!hinoki.isUndefined(value)) {
      return {
        value: value,
        name: name
      };
    }
    factory = (ref1 = container.factories) != null ? ref1[name] : void 0;
    if (factory == null) {
      return;
    }
    if ((factory.$inject == null) && 'function' === typeof factory) {
      factory.$inject = hinoki.parseFunctionArguments(factory);
    }
    return {
      factory: factory,
      name: name
    };
  };
  hinoki.inherits = function(constructor, superConstructor) {
    var proxyConstructor;
    if ('function' === typeof Object.create) {
      constructor.prototype = Object.create(superConstructor.prototype);
      return constructor.prototype.constructor = constructor;
    } else {
      proxyConstructor = function() {};
      proxyConstructor.prototype = superConstructor.prototype;
      constructor.prototype = new proxyConstructor;
      return constructor.prototype.constructor = constructor;
    }
  };
  hinoki.BaseError = function() {};
  hinoki.inherits(hinoki.BaseError, Error);
  hinoki.ErrorInResolversError = function(path, containers, error) {
    this.name = 'ErrorInResolversError';
    this.message = "error in resolvers for '" + path[0] + "' (" + (hinoki.pathToString(path)) + "). original error: " + (error.toString());
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.containers = containers;
    this.error = error;
  };
  hinoki.inherits(hinoki.ErrorInResolversError, hinoki.BaseError);
  hinoki.UnresolvableError = function(path, container) {
    this.name = 'UnresolvableError';
    this.message = "unresolvable name '" + path[0] + "' (" + (hinoki.pathToString(path)) + ")";
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.container = container;
  };
  hinoki.inherits(hinoki.UnresolvableError, hinoki.BaseError);
  hinoki.InvalidResolutionError = function(path, resolution, errors) {
    var lines;
    this.name = 'InvalidResolutionError';
    lines = errors;
    lines.unshift("errors in resolution returned by resolvers for '" + path[0] + "' (" + (hinoki.pathToString(path)) + "):");
    this.message = lines.join('\n');
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.resolution = resolution;
  };
  hinoki.inherits(hinoki.InvalidResolutionError, hinoki.BaseError);
  hinoki.CircularDependencyError = function(path, containers) {
    this.name = 'CircularDependencyError';
    this.message = "circular dependency " + (hinoki.pathToString(path));
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.containers = containers;
  };
  hinoki.inherits(hinoki.CircularDependencyError, hinoki.BaseError);
  hinoki.ThrowInFactoryError = function(path, container, error) {
    this.name = 'ThrowInFactoryError';
    this.message = "error in factory for '" + path[0] + "'. original error: " + (error.toString());
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.container = container;
    this.error = error;
  };
  hinoki.inherits(hinoki.ThrowInFactoryError, hinoki.BaseError);
  hinoki.FactoryReturnedUndefinedError = function(path, container, factory) {
    this.name = 'FactoryReturnedUndefinedError';
    this.message = "factory for '" + path[0] + "' returned undefined";
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.container = container;
    this.factory = factory;
  };
  hinoki.inherits(hinoki.FactoryReturnedUndefinedError, hinoki.BaseError);
  hinoki.PromiseRejectedError = function(path, container, error) {
    this.name = 'PromiseRejectedError';
    this.message = "promise returned from factory for '" + path[0] + "' was rejected. original error: " + (error.toString());
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.container = container;
    this.error = error;
  };
  hinoki.inherits(hinoki.PromiseRejectedError, hinoki.BaseError);
  hinoki.pathToString = function(path) {
    return path.join(' <- ');
  };
  hinoki.isObject = function(x) {
    return x === Object(x);
  };
  hinoki.isThenable = function(x) {
    return hinoki.isObject(x) && 'function' === typeof x.then;
  };
  hinoki.isUndefined = function(x) {
    return 'undefined' === typeof x;
  };
  hinoki.isNull = function(x) {
    return null === x;
  };
  hinoki.isExisting = function(x) {
    return x != null;
  };
  hinoki.identity = function(x) {
    return x;
  };
  hinoki.some = function(array, iterator, predicate, sentinel) {
    var i, length, result;
    if (iterator == null) {
      iterator = hinoki.identity;
    }
    if (predicate == null) {
      predicate = hinoki.isExisting;
    }
    if (sentinel == null) {
      sentinel = void 0;
    }
    i = 0;
    length = array.length;
    while (i < length) {
      result = iterator(array[i], i);
      if (predicate(result, i)) {
        return result;
      }
      i++;
    }
    return sentinel;
  };
  hinoki.arrayOfStringsHasDuplicates = function(array) {
    var i, length, value, valuesSoFar;
    i = 0;
    length = array.length;
    valuesSoFar = {};
    while (i < length) {
      value = array[i];
      if (Object.prototype.hasOwnProperty.call(valuesSoFar, value)) {
        return true;
      }
      valuesSoFar[value] = true;
      i++;
    }
    return false;
  };
  hinoki.coerceToArray = function(arg) {
    if (Array.isArray(arg)) {
      return arg;
    }
    if (arg == null) {
      return [];
    }
    return [arg];
  };
  hinoki.startingWith = function(xs, x) {
    var index;
    index = xs.indexOf(x);
    if (index === -1) {
      return [];
    }
    return xs.slice(index);
  };
  hinoki.parseFunctionArguments = function(fun) {
    var argumentPart, dependencies, string;
    if ('function' !== typeof fun) {
      throw new Error('argument must be a function');
    }
    string = fun.toString();
    argumentPart = string.slice(string.indexOf('(') + 1, string.indexOf(')'));
    dependencies = argumentPart.match(/([^\s,]+)/g);
    if (dependencies) {
      return dependencies;
    } else {
      return [];
    }
  };
  hinoki.getNamesToInject = function(factory) {
    if (factory.$inject != null) {
      return factory.$inject;
    } else {
      return hinoki.parseFunctionArguments(factory);
    }
  };
  hinoki.getAndCacheNamesToInject = function(factory) {
    var names;
    if (factory.$inject != null) {
      return factory.$inject;
    } else {
      names = hinoki.parseFunctionArguments(factory);
      factory.$inject = names;
      return names;
    }
  };
  return hinoki;
});
