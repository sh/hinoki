// Generated by CoffeeScript 1.9.1
(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define(['bluebird'], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory(require('bluebird'), require('fs'), require('path'));
  } else {
    return root.hinoki = factory(root.Promise);
  }
})(this, function(Promise, fs, path) {
  var hinoki;
  hinoki = function(lifetimeOrLifetimes, nameOrNamesOrFunction) {
    var lifetimes, names, paths;
    lifetimes = Array.isArray(lifetimeOrLifetimes) ? lifetimeOrLifetimes : [lifetimeOrLifetimes];
    if (lifetimes.length === 0) {
      throw new Error('at least 1 lifetime is required');
    }
    if ('function' === typeof nameOrNamesOrFunction) {
      names = hinoki.getNamesToInject(nameOrNamesOrFunction);
      paths = names.map(hinoki.coerceToArray);
      return hinoki.getValuesInLifetimes(lifetimes, 0, paths).spread(nameOrNamesOrFunction);
    }
    if (Array.isArray(nameOrNamesOrFunction)) {
      names = hinoki.coerceToArray(nameOrNamesOrFunction);
      paths = names.map(hinoki.coerceToArray);
      return hinoki.getValuesInLifetimes(lifetimes, 0, paths);
    }
    path = hinoki.coerceToArray(nameOrNamesOrFunction);
    return hinoki.getValueInLifetimes(lifetimes, 0, path);
  };
  hinoki.getValuesInLifetimes = function(lifetimes, lifetimeStartIndex, paths) {
    return Promise.all(paths.map(function(path) {
      return hinoki.getValueInLifetimes(lifetimes, lifetimeStartIndex, path);
    }));
  };
  hinoki.getValueInLifetimes = function(lifetimes, lifetimeStartIndex, path) {
    var index, length, result;
    index = lifetimeStartIndex - 1;
    length = lifetimes.length;
    while (++index < length) {
      result = hinoki.getValueInLifetime(lifetimes, index, path);
      if (result != null) {
        return result;
      }
    }
    return Promise.reject(new hinoki.UnresolvableError(path, lifetimes));
  };
  hinoki.getValueInLifetime = function(lifetimes, lifetimeIndex, path) {
    var lifetime, name, promise, ref, ref1, value;
    lifetime = lifetimes[lifetimeIndex];
    name = path[0];
    if (lifetime.mapName != null) {
      name = lifetime.mapName(name);
    }
    value = (ref = lifetime.values) != null ? ref[name] : void 0;
    if (!hinoki.isUndefined(value)) {
      if (typeof lifetime.debug === "function") {
        lifetime.debug({
          event: 'valueWasResolved',
          path: path,
          value: value
        });
      }
      return Promise.resolve(value);
    }
    promise = (ref1 = lifetime.promisesAwaitingResolution) != null ? ref1[name] : void 0;
    if (promise != null) {
      if (typeof lifetime.debug === "function") {
        lifetime.debug({
          event: 'valueIsAlreadyAwaitingResolution',
          path: path,
          promise: promise
        });
      }
      return promise;
    }
    return hinoki.weNeedAFactory(lifetimes, lifetimeIndex, path);
  };
  hinoki.getFactoryFromSource = function(factorySource, name) {
    if ('function' === typeof factorySource) {
      return factorySource(name);
    } else {
      return factorySource[name];
    }
  };
  hinoki.weNeedAFactory = function(lifetimes, lifetimeIndex, path) {
    var factory, factorySource, factorySourceIndex, factorySourceLength, factorySources, lifetime;
    lifetime = lifetimes[lifetimeIndex];
    if (lifetime.factories == null) {
      return;
    }
    if (Array.isArray(lifetime.factories)) {
      factorySources = lifetime.factories;
    } else {
      factorySources = [lifetime.factories];
    }
    factorySourceIndex = -1;
    factorySourceLength = factorySources.length;
    while (++factorySourceIndex < factorySourceLength) {
      factorySource = factorySources[factorySourceIndex];
      factory = hinoki.getFactoryFromSource(factorySource, path[0]);
      if (factory != null) {
        if (lifetime.mapFactory != null) {
          factory = lifetime.mapFactory(factory);
        }
        return hinoki.weHaveAFactory(lifetimes, lifetimeIndex, path, factorySource, factory);
      }
    }
  };
  hinoki.weHaveAFactory = function(lifetimes, lifetimeIndex, path, factorySource, factory) {
    var dependenciesPromise, dependencyNames, dependencyPaths, factoryCallResultPromise, lifetime, newPath;
    lifetime = lifetimes[lifetimeIndex];
    if (hinoki.arrayOfStringsHasDuplicates(path)) {
      return Promise.reject(new hinoki.CircularDependencyError(path, lifetime, factory));
    }
    if (typeof lifetime.debug === "function") {
      lifetime.debug({
        event: 'factoryWasResolved',
        path: path,
        factorySource: factorySource,
        factory: factory
      });
    }
    dependencyNames = hinoki.getAndCacheNamesToInject(factory);
    newPath = path.slice();
    dependencyPaths = dependencyNames.map(function(x) {
      return hinoki.coerceToArray(x).concat(newPath);
    });
    dependenciesPromise = dependencyPaths.length !== 0 ? hinoki.getValuesInLifetimes(lifetimes, lifetimeIndex, dependencyPaths) : Promise.resolve([]);
    factoryCallResultPromise = dependenciesPromise.then(function(dependencyValues) {
      return hinoki.callFactory(lifetime, newPath, factory, dependencyValues);
    });
    if (!factory.$nocache) {
      if (lifetime.promisesAwaitingResolution == null) {
        lifetime.promisesAwaitingResolution = {};
      }
      lifetime.promisesAwaitingResolution[path[0]] = factoryCallResultPromise;
    }
    return factoryCallResultPromise.then(function(value) {
      if (hinoki.isUndefined(value)) {
        return Promise.reject(new hinoki.FactoryReturnedUndefinedError(newPath, lifetime, factory));
      }
      if (!factory.$nocache) {
        if (lifetime.values == null) {
          lifetime.values = {};
        }
        lifetime.values[path[0]] = value;
      }
      return value;
    })["finally"](function() {
      if (!factory.$nocache) {
        delete lifetime.promisesAwaitingResolution[path[0]];
        if (Object.keys(lifetime.promisesAwaitingResolution).length === 0) {
          return delete lifetime.promisesAwaitingResolution;
        }
      }
    });
  };
  hinoki.callFactory = function(lifetime, path, factory, dependencyValues) {
    var error, valueOrPromise;
    try {
      valueOrPromise = factory.apply(null, dependencyValues);
    } catch (_error) {
      error = _error;
      return Promise.reject(new hinoki.ThrowInFactoryError(path, lifetime, factory, error));
    }
    if (!hinoki.isThenable(valueOrPromise)) {
      if (typeof lifetime.debug === "function") {
        lifetime.debug({
          event: 'valueWasCreated',
          path: path,
          value: valueOrPromise,
          factory: factory
        });
      }
      return Promise.resolve(valueOrPromise);
    }
    if (typeof lifetime.debug === "function") {
      lifetime.debug({
        event: 'promiseWasCreated',
        path: path,
        promise: valueOrPromise,
        factory: factory
      });
    }
    return Promise.resolve(valueOrPromise).then(function(value) {
      if (typeof lifetime.debug === "function") {
        lifetime.debug({
          event: 'promiseWasResolved',
          path: path,
          value: value,
          factory: factory
        });
      }
      return value;
    })["catch"](function(rejection) {
      return Promise.reject(new hinoki.PromiseRejectedError(path, lifetime, rejection));
    });
  };
  hinoki.inherits = function(constructor, superConstructor) {
    var proxyConstructor;
    if ('function' === typeof Object.create) {
      constructor.prototype = Object.create(superConstructor.prototype);
      return constructor.prototype.constructor = constructor;
    } else {
      proxyConstructor = function() {};
      proxyConstructor.prototype = superConstructor.prototype;
      constructor.prototype = new proxyConstructor;
      return constructor.prototype.constructor = constructor;
    }
  };
  hinoki.BaseError = function() {};
  hinoki.inherits(hinoki.BaseError, Error);
  hinoki.UnresolvableError = function(path, lifetime) {
    this.name = 'UnresolvableError';
    this.message = "unresolvable name '" + path[0] + "' (" + (hinoki.pathToString(path)) + ")";
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.lifetime = lifetime;
  };
  hinoki.inherits(hinoki.UnresolvableError, hinoki.BaseError);
  hinoki.CircularDependencyError = function(path, lifetime, factory) {
    this.name = 'CircularDependencyError';
    this.message = "circular dependency " + (hinoki.pathToString(path));
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.lifetime = lifetime;
    this.factory = factory;
  };
  hinoki.inherits(hinoki.CircularDependencyError, hinoki.BaseError);
  hinoki.ThrowInFactoryError = function(path, lifetime, factory, error) {
    this.name = 'ThrowInFactoryError';
    this.message = "error in factory for '" + path[0] + "'. original error: " + (error.toString());
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.lifetime = lifetime;
    this.factory = factory;
    this.error = error;
  };
  hinoki.inherits(hinoki.ThrowInFactoryError, hinoki.BaseError);
  hinoki.FactoryReturnedUndefinedError = function(path, lifetime, factory) {
    this.name = 'FactoryReturnedUndefinedError';
    this.message = "factory for '" + path[0] + "' returned undefined";
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.lifetime = lifetime;
    this.factory = factory;
  };
  hinoki.inherits(hinoki.FactoryReturnedUndefinedError, hinoki.BaseError);
  hinoki.PromiseRejectedError = function(path, lifetime, error) {
    this.name = 'PromiseRejectedError';
    this.message = "promise returned from factory for '" + path[0] + "' was rejected. original error: " + (error.toString());
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.path = path;
    this.lifetime = lifetime;
    this.error = error;
  };
  hinoki.inherits(hinoki.PromiseRejectedError, hinoki.BaseError);
  hinoki.pathToString = function(path) {
    return path.join(' <- ');
  };
  hinoki.isObject = function(x) {
    return x === Object(x);
  };
  hinoki.isThenable = function(x) {
    return hinoki.isObject(x) && 'function' === typeof x.then;
  };
  hinoki.isUndefined = function(x) {
    return 'undefined' === typeof x;
  };
  hinoki.isNull = function(x) {
    return null === x;
  };
  hinoki.isExisting = function(x) {
    return x != null;
  };
  hinoki.identity = function(x) {
    return x;
  };
  hinoki.arrayOfStringsHasDuplicates = function(array) {
    var i, length, value, valuesSoFar;
    i = 0;
    length = array.length;
    valuesSoFar = {};
    while (i < length) {
      value = array[i];
      if (Object.prototype.hasOwnProperty.call(valuesSoFar, value)) {
        return true;
      }
      valuesSoFar[value] = true;
      i++;
    }
    return false;
  };
  hinoki.coerceToArray = function(arg) {
    if (Array.isArray(arg)) {
      return arg;
    }
    if (arg == null) {
      return [];
    }
    return [arg];
  };
  hinoki.parseFunctionArguments = function(fun) {
    var argumentPart, dependencies, string;
    if ('function' !== typeof fun) {
      throw new Error('argument must be a function');
    }
    string = fun.toString();
    argumentPart = string.slice(string.indexOf('(') + 1, string.indexOf(')'));
    dependencies = argumentPart.match(/([^\s,]+)/g);
    if (dependencies) {
      return dependencies;
    } else {
      return [];
    }
  };
  hinoki.getNamesToInject = function(factory) {
    if (factory.$inject != null) {
      return factory.$inject;
    } else {
      return hinoki.parseFunctionArguments(factory);
    }
  };
  hinoki.getAndCacheNamesToInject = function(factory) {
    var names;
    if (factory.$inject != null) {
      return factory.$inject;
    } else {
      names = hinoki.parseFunctionArguments(factory);
      factory.$inject = names;
      return names;
    }
  };
  if ((fs != null) && (path != null)) {
    hinoki.requireSource = function(filepath) {
      if ('string' !== typeof filepath) {
        throw new Error('argument must be a string');
      }
      return hinoki.source.baseRequire(filepath, {});
    };
    hinoki.baseRequireSource = function(filepath, object) {
      var extension, filenames, stat;
      stat = fs.statSync(filepath);
      if (stat.isFile()) {
        extension = path.extname(filepath);
        if (extension !== '.js' && extension !== '.coffee') {
          return;
        }
        if (extension === '.coffee') {
          require('coffee-script/register');
        }
        extension = require(filepath);
        Object.keys(extension).map(function(key) {
          if ('function' !== typeof extension[key]) {
            throw new Error('export is not a function: ' + key + ' in :' + filepath);
          }
          if (object[key] != null) {
            throw new Error('duplicate export: ' + key + ' in: ' + filepath + '. first was in: ' + object[key].$file);
          }
          object[key] = extension[key];
          return object[key].$file = filepath;
        });
      } else if (stat.isDirectory()) {
        filenames = fs.readdirSync(filepath);
        filenames.forEach(function(filename) {
          return loadFactories(object, path.join(filepath, filename));
        });
      }
      return object;
    };
  }
  hinoki.source = function(arg) {
    var coercedSources;
    if ('function' === typeof arg) {
      return arg;
    } else if (Array.isArray(arg)) {
      coercedSources = arg.map(hinoki.source);
      return function(name) {
        var index, length, result;
        index = -1;
        length = sources.length;
        while (++index < length) {
          result = coercedSources[index](name);
          if (result != null) {
            return result;
          }
        }
        return null;
      };
    } else if ('string' === typeof arg) {
      return hinoki.requireSource(arg);
    } else if ('object' === typeof arg) {
      return function(name) {
        return functionOrObject[name];
      };
    } else {
      throw new Error('argument must be a function, string, object or array of these');
    }
  };
  return hinoki;
});
